#pragma once

#include <functional>
#include <type_traits>

#include "Error.h"
#include "MiscMacros.h"
#include "Result.h"

#ifndef OPTION
	#define OPTION

namespace apex::utils {
	/// @brief Represents an optional value.
	/// Every `Option` is either `Some` and contains a value, or `None`, and does
	/// not. Useful for things such as:
	/// * * Optional members/fields
	/// * * Members/fields that can be loaned or "taken"
	/// * * Optional function arguments
	/// * * Nullable types/pointers
	/// * * Return values for functions not defined over their entire input range
	///
	/// @tparam T - The type of the potentially-contained value
	///
	/// @tags {`utils`}
	template<typename T, bool copyable = std::is_copy_constructible_v<T> && !std::is_pointer_v<T>>
	class [[nodiscard]] Option {
	  public:
		Option(const Option<T, copyable>& option) = default;
		Option(Option<T, copyable>&& option) noexcept = default;
		~Option() noexcept = default;

		/// @brief Constructs an `Option<T>` containing `some`, aka a `Some` variant
		/// containing `some` aka `Some(some)`
		///
		/// @param some - The value to store in this `Option<T>`
		///
		/// @return `Some(some)`
		[[nodiscard]] static inline auto Some(T some) noexcept -> Option<T, copyable> {
			return Option<T, copyable>(some);
		}

		/// @brief Constructs an empty `Option<T>`, aka a `None`
		///
		/// @return `None`
		[[nodiscard]] static inline auto None() noexcept -> Option<T, copyable> {
			return Option<T, copyable>();
		}

		/// @brief Returns `true` if this is `Some`, `false` if this is `None`
		///
		/// @return Whether this is `Some`
		[[nodiscard]] inline auto isSome() const noexcept -> bool {
			return mIsSome;
		}

		/// @brief Returns `true` if this is `None`, `false` if this is `Some`
		///
		/// @return Whether this is `None`
		[[nodiscard]] inline auto isNone() const noexcept -> bool {
			return !mIsSome;
		}

		/// @brief Maps this `Option<T>` to an `Option<U>`,
		/// returning `Some(U)` if this is Some, or `None` if this is `None`
		///
		/// @tparam U - The type to map to
		/// @param mapFunc - The function to perform the mapping
		///
		/// @return Option<U> - `Some(U)` if this is Some, or `None` if this is `None`
		template<typename U>
		[[nodiscard]] inline auto
		map(std::function<U(T) const> mapFunc) const noexcept -> Option<U> {
			if(mIsSome) {
				return Option<U>::Some(mapFunc(mSome));
			}
			else {
				return Option<U>::None();
			}
		}

		/// @brief Maps this `Option<T>` to a `U`,
		/// returning `U` (mapped by `mapFunc`) if this is `Some`,
		/// or `defaultValue` if this is `None`
		///
		/// @tparam U - The type to map to
		/// @param mapFunc - The function to perform the mapping
		/// @param defaultValue - The default value
		///
		/// @return The result of the mapping if this is `Some`, or `defaultValue`
		template<typename U>
		[[nodiscard]] inline auto
		mapOr(std::function<U(T) const> mapFunc, U defaultValue) const noexcept -> U {
			if(mIsSome) {
				return mapFunc(mSome);
			}
			else {
				return defaultValue;
			}
		}

		/// @brief Maps this `Option<T>` to a `U`,
		/// returning `U` (mapped by `mapFunc`) if this is `Some`,
		/// or `U` (the default value returned by `defaultGenerator`)
		/// if this is `None`
		///
		/// @tparam U - The type to map to
		/// @param mapFunc - The function to perform the mapping
		/// @param defaultGenerator - The function to generate the default value
		///
		/// @return The result of the mapping if this is `Some`,
		///			or the value returned by `defaultGenerator` if this is
		///`None`
		template<typename U>
		[[nodiscard]] inline auto
		mapOrElse(std::function<U(T) const> mapFunc,
				  std::function<U()> defaultGenerator) const noexcept -> U {
			if(mIsSome) {
				return mapFunc(mSome);
			}
			else {
				return defaultGenerator();
			}
		}

		/// @brief Converts this `Option<T>` to a `Result<T, E>`, consuming this
		/// `Option<T>`. Returns `Ok(T)` if this is `Some` or `Err(error)` if this is
		/// `None`
		///
		/// @tparam E - The type to return if this is `None`.
		///				Must be an `Error` type (`apex::utils::Error`)
		/// @param error - The `Error` to return if this `Option<T>` is `None`
		///
		/// @return `Ok(T)` if this is `Some`, `Err(error)` if this is `None`
		template<typename E, typename Enable = std::enable_if_t<std::is_base_of_v<Error, E>, E>>
		[[nodiscard]] inline auto okOr(E error) noexcept -> Result<T, E> {
			if(mIsSome) {
				auto res = Result<T, E>::Ok(std::move(mSome));
				mIsSome = false;
				this->~Option();
				return std::move(res);
			}
			else {
				this->~Option();
				return Result<T, E>::Err(error);
			}
		}

		/// @brief Converts this `Option<T>` to a `Result<T, E>`, consuming this
		/// `Option<T>`. Returns `Ok(T)` if this is `Some`, or `Err(E)` (where E is
		/// generated by `errorGenerator`) if this is `None`
		///
		/// @tparam E - The type to return if this is `None`.
		///				Must be an `Error` type (`apex::utils::Error`)
		/// @param errorGenerator - The function to generate the `Error` value
		///
		/// @return `Ok(T)` if this is `Some`, `Err(E)` if this is `None`
		template<typename E, typename Enable = std::enable_if_t<std::is_base_of_v<Error, E>, E>>
		[[nodiscard]] inline auto
		okOrElse(std::function<E() const> errorGenerator) noexcept -> Result<T, E> {
			if(mIsSome) {
				auto res = Result<T, E>::Ok(std::move(mSome));
				mIsSome = false;
				this->~Option();
				return std::move(res);
			}
			else {
				this->~Option();
				return Result<T, E>::Err(errorGenerator());
			}
		}

		/// @brief Returns the contained `T`, consuming this `Option`.
		/// If this is not `Some`, then `std::terminate` is called
		///
		/// @return The contained `T`
		[[nodiscard]] inline auto unwrap() noexcept -> T {
			if(mIsSome) {
				auto some = std::move(mSome);
				mIsSome = false;
				this->~Option();
				return std::move(some);
			}
			else {
				std::terminate();
			}
		}

		/// @brief Returns the contained `T` if this is `Some`, consuming this
		/// `Option`. If this is not `Some`, then returns `defaultValue`.
		///
		/// @param defaultValue - The value to return if this is `None`
		///
		/// @return The contained `T` if this is `Some`, or `defaultValue`
		[[nodiscard]] inline auto unwrapOr(T defaultValue) noexcept -> T {
			if(mIsSome) {
				auto some = std::move(mSome);
				mIsSome = false;
				this->~Option();
				return std::move(some);
			}
			else {
				this->~Option();
				return defaultValue;
			}
		}

		/// @brief Returns the contained `T` if this is `Some`, consuming this
		/// `Option<T>`. If this is not `Some`, then returns the value generated by
		/// `defaultGenerator`.
		///
		/// @param defaultGenerator - The function to generate the value returned if
		/// this is `None`
		///
		/// @return The contained `T` if this is `Some`, or the value generated by
		/// `defaultGenerator`
		[[nodiscard]] inline auto
		unwrapOrElse(std::function<T() const> defaultGenerator) noexcept -> T {
			if(mIsSome) {
				auto some = std::move(mSome);
				mIsSome = false;
				this->~Option();
				return std::move(some);
			}
			else {
				this->~Option();
				return defaultGenerator();
			}
		}

		/// @brief Similar to `unwrap`, except doesn't consume this `Option`.
		/// Returns a pointer to the mutable `T` if this is `Some`, otherwise calls
		/// `std::terminate`
		///
		/// @return A pointer to the contained `T`
		[[nodiscard]] inline auto getMut() noexcept -> T* {
			if(mIsSome) {
				return &mSome;
			}
			else {
				std::terminate();
			}
		}

		/// @brief Similar to `unwrap`, except doesn't consume this `Option`.
		/// Returns a pointer to the const `T` if this is `Some`, otherwise calls
		/// `std::terminate`
		///
		/// @return An immutable pointer to the contained `T`
		[[nodiscard]] inline auto getConst() const noexcept -> const T* {
			if(mIsSome) {
				return &mSome;
			}
			else {
				std::terminate();
			}
		}

		auto operator=(const Option<T, copyable>& option) -> Option<T, copyable>& = default;
		auto operator=(Option<T, copyable>&& option) noexcept -> Option<T, copyable>& = default;

	  private:
		explicit Option(T some) noexcept : mSome(some), mIsSome(true) {
		}
		Option() = default;

		/// The contained value
		T mSome;
		/// Whether this is `Some`
		bool mIsSome = false;

		APEX_DECLARE_NON_HEAP_ALLOCATABLE()
	};

	template<typename T>
	class [[nodiscard]] Option<T, false> : Option<T, true> {
	  public:
		using Option<T, true>::Some;
		using Option<T, true>::None;
		using Option<T, true>::isSome;
		using Option<T, true>::isNone;
		using Option<T, true>::map;
		using Option<T, true>::mapOr;
		using Option<T, true>::mapOrElse;
		using Option<T, true>::okOr;
		using Option<T, true>::okOrElse;
		using Option<T, true>::unwrap;
		using Option<T, true>::unwrapOr;
		using Option<T, true>::unwrapOrElse;
		using Option<T, true>::getMut;
		using Option<T, true>::getConst;

		Option(const Option<T>& option) = delete;
		Option(Option<T>& option) = delete;
		~Option() noexcept = default;

		auto operator=(const Option<T>& option) = delete;
		auto operator=(Option<T> option) = delete;

	  private:
		using Option<T, true>::Option;
	};

	template<typename T>
	class [[nodiscard]] Option<T*, false> : Option<T, true> {
	  public:
		using Option<T, true>::None;
		using Option<T, true>::isSome;
		using Option<T, true>::isNone;
		using Option<T, true>::map;
		using Option<T, true>::mapOr;
		using Option<T, true>::mapOrElse;
		using Option<T, true>::okOr;
		using Option<T, true>::okOrElse;
		using Option<T, true>::unwrap;
		using Option<T, true>::unwrapOr;
		using Option<T, true>::unwrapOrElse;
		Option(const Option<T*>& option) = delete;
		Option(Option<T*>& option) = delete;

		auto operator=(const Option<T*>& option) = delete;
		auto operator=(Option<T*> option) = delete;

		~Option() noexcept {
			if(mIsSome) {
				delete mSome;
				mSome = gsl::owner<T*>(nullptr);
			}
		}

		/// @brief Constructs an `Option<T>` containing `some`, aka a `Some` variant
		/// containing `some` aka `Some(some)`
		/// Takes ownership of `some`
		///
		/// @param some - The value to store in this `Option<T>`
		///
		/// @return `Some(some)`
		[[nodiscard]] static inline auto Some(gsl::owner<T*> some) noexcept -> Option<T*>;

		/// @brief Similar to `unwrap`, except doesn't consume this `Option`.
		/// Returns a pointer to the mutable `T` if this is `Some`, otherwise calls
		/// `std::terminate`
		///
		/// @return A pointer to the contained `T`
		[[nodiscard]] inline auto getMut() noexcept -> T* {
			if(mIsSome) {
				return gsl::not_null<T*>(mSome);
			}
			else {
				std::terminate();
			}
		}

		/// @brief Similar to `unwrap`, except doesn't consume this `Option`.
		/// Returns a pointer to the const `T` if this is `Some`, otherwise calls
		/// `std::terminate`
		///
		/// @return A pointer to the contained `T`
		[[nodiscard]] inline auto getConst() const noexcept -> const T* {
			if(mIsSome) {
				return gsl::not_null<T*>(mSome);
			}
			else {
				std::terminate();
			}
		}

	  private:
		explicit Option(gsl::owner<T*> some) noexcept : mSome(some), mIsSome(true) {
		}
		Option() noexcept = default;

		/// The contained value
		gsl::owner<T*> mSome = nullptr;
		/// Whether this is `Some`
		bool mIsSome = false;

		APEX_DECLARE_NON_HEAP_ALLOCATABLE()
	};
} // namespace apex::utils

#endif // OPTION
