#pragma once

#include <functional>

namespace apex {
	namespace utils {

		template<typename T, typename E>
			class Result;

		/// @brief Represents an optional value.
		/// Every `Option` is either `Some` and contains a value, or `None`, and does not.
		/// Useful for things such as:
		/// * * Optional members/fields
		/// * * Members/fields that can be loaned or "taken"
		/// * * Optional function arguments
		/// * * Nullable types/pointers
		/// * * Return values for functions not defined over their entire input range
		///
		/// @tparam T - The type of the potentially-contained value
		///
		/// @tags {`utils`}
		template<typename T>
			class Option {
				public:
					~Option();

					/// @brief Constructs an `Option<T>` containing `some`, aka a `Some` variant
					/// containing `some` aka `Some(some)`
					///
					/// @param some - The value to store in this `Option<T>`
					///
					/// @return `Some(some)`
					static Option<T> Some(T some);

					/// @brief Constructs an empty `Option<T>`, aka a `None`
					///
					/// @return `None`
					static Option<T> None();

					/// @brief Returns `true` if this is `Some`, `false` if this is `None`
					///
					/// @return Whether this is `Some`
					const bool isSome() const;

					/// @brief Returns `true` if this is `None`, `false` if this is `Some`
					///
					/// @return Whether this is `None`
					const bool isNone() const;

					/// @brief Maps this `Option<T>` to an `Option<U>`,
					/// returning `Some(U)` if this is Some, or `None` if this is `None`
					///
					/// @tparam U - The type to map to
					/// @param mapFunc - The function to perform the mapping
					///
					/// @return Option<U> - `Some(U)` if this is Some, or `None` if this is `None`
					template<typename U>
						Option<U> map(std::function<U(T) const> mapFunc) const;

					/// @brief Maps this `Option<T>` to a `U`,
					/// returning `U` (mapped by `mapFunc`) if this is `Some`,
					/// or `defaultValue` if this is `None`
					///
					/// @tparam U - The type to map to
					/// @param mapFunc - The function to perform the mapping
					/// @param defaultValue - The default value
					///
					/// @return The result of the mapping if this is `Some`, or `defaultValue`
					template<typename U>
						U mapOr(std::function<U(T) const> mapFunc, U defaultValue) const;

					/// @brief Maps this `Option<T>` to a `U`,
					/// returning `U` (mapped by `mapFunc`) if this is `Some`,
					/// or `U` (the default value returned by `defaultGenerator`)
					/// if this is `None`
					///
					/// @tparam U - The type to map to
					/// @param mapFunc - The function to perform the mapping
					/// @param defaultGenerator - The function to generate the default value
					///
					/// @return The result of the mapping if this is `Some`,
					///			or the value returned by `defaultGenerator` if this is `None`
					template<typename U>
						U mapOrElse(std::function<U(T) const> mapFunc,
								std::function<U()> defaultGenerator) const;

					/// @brief Converts this `Option<T>` to a `Result<T, E>`, consuming this `Option<T>`.
					/// Returns `Ok(T)` if this is `Some` or `Err(error)` if this is `None`
					///
					/// @tparam E - The type to return if this is `None`.
					///				Must be an `Error` type (`apex::utils::Error`)
					/// @param error - The `Error` to return if this `Option<T>` is `None`
					///
					/// @return `Ok(T)` if this is `Some`, `Err(error)` if this is `None`
					template<typename E>
						Result<T, E> okOr(E error) const;

					/// @brief Converts this `Option<T>` to a `Result<T, E>`, consuming this `Option<T>`.
					/// Returns `Ok(T)` if this is `Some`, or `Err(E)`
					/// (where E is generated by `errorGenerator`) if this is `None`
					///
					/// @tparam E - The type to return if this is `None`.
					///				Must be an `Error` type (`apex::utils::Error`)
					/// @param errorGenerator - The function to generate the `Error` value
					///
					/// @return `Ok(T)` if this is `Some`, `Err(E)` if this is `None`
					template<typename E>
						Result<T, E> okOrElse(std::function<E() const> errorGenerator) const;

					/// @brief Returns the contained `T`, consuming this `Option<T>`.
					/// If this is not `Some`, then `T` will be a default value (if a default constructor
					/// is available) or uninitialized (if one is not available)
					///
					/// @return The contained `T`
					T unwrap();

					/// @brief Returns the contained `T` if this is `Some`, consuming this `Option<T>`.
					/// If this is not `Some`, then returns `defaultValue`.
					///
					/// @param defaultValue - The value to return if this is `None`
					///
					/// @return The contained `T` if this is `Some`, or `defaultValue`
					T unwrapOr(T defaultValue);

					/// @brief Returns the contained `T` if this is `Some`, consuming this `Option<T>`.
					/// If this is not `Some`, then returns the value generated by `defaultGenerator`.
					///
					/// @param defaultGenerator - The function to generate the value returned if this is `None`
					///
					/// @return The contained `T` if this is `Some`, or the value generated by `defaultGenerator`
					T unwrapOrElse(std::function<T() const> defaultGenerator);

					/// @brief Returns a pointer to the contained `T` if this is `Some`,
					/// or `nullptr` if this is `None`
					///
					/// @return A pointer to the contained `T`
					const T* getMut();

					/// @brief Retuns an immutable pointer to the contained `T` if this is `Some`,
					/// or `nullptr` if this is `None`
					///
					/// @return An immutable pointer to the contained `T`
					const T* const getConst() const;

				private:
					Option(T some);
					Option();

					///The contained value
					T mSome;
					///Whether this is `Some`
					bool mIsSome = false;
			};
	}
}
