#include <type_traits>

#include "Error.h"
#include "Option.h"
#include "Result.h"

namespace apex {
	namespace utils {

		template<typename T>
			Option<T>::~Option() {

			}

		/// @brief Constructs an `Option<T>` containing `some`, aka a `Some` variant
		/// containing `some` aka `Some(some)`
		///
		/// @param some - The value to store in this `Option<T>`
		///
		/// @return `Some(some)`
		template<typename T>
			inline Option<T> Option<T>::Some(T some) {
				return Option(some);
			}

		/// @brief Constructs an empty `Option<T>`, aka a `None`
		///
		/// @return `None`
		template<typename T>
			inline Option<T> Option<T>::None() {
				return Option();
			}

		/// @brief Returns `true` if this is `Some`, `false` if this is `None`
		///
		/// @return Whether this is `Some`
		template<typename T>
			inline const bool Option<T>::isSome() const {
				return mIsSome;
			}

		/// @brief Returns `true` if this is `None`, `false` if this is `Some`
		///
		/// @return Whether this is `None`
		template<typename T>
			inline const bool Option<T>::isNone() const {
				return !mIsSome;
			}

		/// @brief Maps this `Option<T>` to an `Option<U>`,
		/// returning `Some(U)` if this is Some, or `None` if this is `None`
		///
		/// @tparam U - The type to map to
		/// @param mapFunc - The function to perform the mapping
		///
		/// @return Option<U> - `Some(U)` if this is Some, or `None` if this is `None`
		template<typename T>
			template<typename U>
			Option<U> Option<T>::map(std::function<U(T) const> mapFunc) const {
				if(mIsSome) return Option<U>::Some(mapFunc(mSome));
				else return Option<U>::None;
			}

		/// @brief Maps this `Option<T>` to a `U`,
		/// returning `U` (mapped by `mapFunc`) if this is `Some`,
		/// or `defaultValue` if this is `None`
		///
		/// @tparam U - The type to map to
		/// @param mapFunc - The function to perform the mapping
		/// @param defaultValue - The default value
		///
		/// @return The result of the mapping if this is `Some`, or `defaultValue`
		template<typename T>
			template<typename U>
			U Option<T>::mapOr(std::function<U(T) const> mapFunc, U defaultValue) const {
				if(mIsSome) return mapFunc(mSome);
				else return defaultValue;
			}

		/// @brief Maps this `Option<T>` to a `U`,
		/// returning `U` (mapped by `mapFunc`) if this is `Some`,
		/// or `U` (the default value returned by `defaultGenerator`)
		/// if this is `None`
		///
		/// @tparam U - The type to map to
		/// @param mapFunc - The function to perform the mapping
		/// @param defaultGenerator - The function to generate the default value
		///
		/// @return The result of the mapping if this is `Some`,
		///			or the value returned by `defaultGenerator` if this is `None`
		template<typename T>
			template<typename U>
			U Option<T>::mapOrElse(std::function<U(T) const> mapFunc,
					std::function<U()> defaultGenerator) const
			{
				if(mIsSome) return mapFunc(mSome);
				else return defaultGenerator();
			}

		/// @brief Converts this `Option<T>` to a `Result<T, E>`, consuming this `Option<T>`.
		/// Returns `Ok(T)` if this is `Some` or `Err(error)` if this is `None`
		///
		/// @tparam E - The type to return if this is `None`.
		///				Must be an `Error` type (`apex::utils::Error`)
		/// @param error - The `Error` to return if this `Option<T>` is `None`
		///
		/// @return `Ok(T)` if this is `Some`, `Err(error)` if this is `None`
		template<typename T>
			template<typename E>
			Result<T, E> Option<T>::okOr(E error) const {
				static_assert(std::is_base_of<Error, E>::value, "E must be an Error type");
				auto temp = *this; //work around to delete this after returning
				if(mIsSome) return Result<T, E>::Ok(std::move(mSome));
				else return Result<T, E>::Err(error);
			}

		/// @brief Converts this `Option<T>` to a `Result<T, E>`, consuming this `Option<T>`.
		/// Returns `Ok(T)` if this is `Some`, or `Err(E)`
		/// (where E is generated by `errorGenerator`) if this is `None`
		///
		/// @tparam E - The type to return if this is `None`.
		///				Must be an `Error` type (`apex::utils::Error`)
		/// @param errorGenerator - The function to generate the `Error` value
		///
		/// @return `Ok(T)` if this is `Some`, `Err(E)` if this is `None`
		template<typename T>
			template<typename E>
			Result<T, E> Option<T>::okOrElse(std::function<E() const> errorGenerator) const {
				static_assert(std::is_base_of<Error, E>::value, "E must be an Error type");
				auto temp = *this; //work around to delete this after returning
				if(mIsSome) return Result<T, E>::Ok(std::move(mSome));
				else return Result<T, E>::Err(errorGenerator());
			}

		/// @brief Returns the contained `T`, consuming this `Option<T>`.
		/// If this is not `Some`, then `T` will be a default value (if a default constructor
		/// is available) or uninitialized (if one is not available)
		///
		/// @return The contained `T`
		template<typename T>
			T Option<T>::unwrap() {
				auto temp = *this; //work around to delete this after returning
				return std::move(mSome);
			}

		/// @brief Returns the contained `T` if this is `Some`, consuming this `Option<T>`.
		/// If this is not `Some`, then returns `defaultValue`.
		///
		/// @param defaultValue - The value to return if this is `None`
		///
		/// @return The contained `T` if this is `Some`, or `defaultValue`
		template<typename T>
			T Option<T>::unwrapOr(T defaultValue) {
				auto temp = *this; //work around to delete this after returning
				if(mIsSome) return std::move(mSome);
				else return defaultValue;
			}

		/// @brief Returns the contained `T` if this is `Some`, consuming this `Option<T>`.
		/// If this is not `Some`, then returns the value generated by `defaultGenerator`.
		///
		/// @param defaultGenerator - The function to generate the value returned if this is `None`
		///
		/// @return The contained `T` if this is `Some`, or the value generated by `defaultGenerator`
		template<typename T>
			T Option<T>::unwrapOrElse(std::function<T() const> defaultGenerator) {
				auto temp = *this; //work around to delete this after returning
				if(mIsSome) return std::move(mSome);
				else return defaultGenerator();
			}

		/// @brief Returns a pointer to the contained `T` if this is `Some`,
		/// or `nullptr` if this is `None`
		///
		/// @return A pointer to the contained `T`
		template<typename T>
			const T* Option<T>::getMut() {
				if(mIsSome) {
					if(std::is_pointer<T>::value) return mSome;
					else return &mSome;
				}
				else return nullptr;
			}

		/// @brief Retuns an immutable pointer to the contained `T` if this is `Some`,
		/// or `nullptr` if this is `None`
		///
		/// @return An immutable pointer to the contained `T`
		template<typename T>
			const T* const Option<T>::getConst() const {
				if(mIsSome) {
					if(std::is_pointer<T>::value) return mSome;
					else return &mSome;
				}
				else return nullptr;
			}

		template<typename T>
			Option<T>::Option(T some) {
				mSome = some;
				mIsSome = true;
			}

		template<typename T>
			Option<T>::Option() {

			}
	}
}
