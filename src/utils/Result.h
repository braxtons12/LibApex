#pragma once

#include <functional>

#include "Error.h"

namespace apex {
	namespace utils {

		template<typename T>
			class Option;

		/// @brief Represents the result of an operation that can fail.
		/// Every `Result` is either `Ok(T)`, indicating success and containing a value
		/// or `Err(E)`, indicating failure and containing an `Error` type
		///
		/// @tparam T - the type contained in the case of success
		/// @tparam E - the `Error` type contained in the case of failure
		template<typename T, typename E>
			class Result {
				public:
					static_assert(std::is_base_of<Error, E>::value, "E must be an Error type");
					~Result();

					/// @brief Constructs a `Result<T, E>` as the `Ok(T)` variant, containing `ok`
					///
					/// @param ok - the success value
					///
					/// @return `Ok(T)`
					static Result<T, E> Ok(T ok);

					/// @brief Constructs a `Result<T, E>` as the `Err(E)` variant, containing `err`
					///
					/// @param err - the failure value
					///
					/// @return `Err(E)`
					static Result<T, E> Err(E err);

					/// @brief Returns `true` if this is `Ok(T)`, `false` if this is `Err(E)`
					///
					/// @return Whether this is `Ok(T)`
					const bool isOk() const;

					/// @brief Returns `true` if this is `Err(E)`, `false` if this is `Ok(T)`
					///
					/// @return Whether this is `Err(E)`
					const bool isErr() const;

					/// @brief Returns a pointer to the contained `T` if this is `Ok(T)`,
					/// or `nullptr` if this is `Err(E)`
					///
					/// @return A pointer to the contained `T`
					const T* getMut();

					/// @brief Returns an immutable pointer to the contained `T` is this is `Ok(T)`
					/// or `nullptr` if this is `Err(E)`
					///
					/// @return An immutable pointer to the contained `T`
					const T* const getConst() const;

					/// @brief Returns the contained `T`, consuming this `Result<T, E>`.
					/// If this is not `Ok(T)`, then `T` will be a default value (if a default
					/// constructor is available) or uninitialized (if one is not available)
					///
					/// @return The contained `T`
					T unwrap();

					/// @brief Returns the contained `T` if this is `Ok(T)`, consuming this `Result<T, E>`
					/// If this is not `Ok(T)`, then returns `defaultValue`
					///
					/// @param defaultValue - The value to return if this is `Err(E)`
					///
					/// @return The contained `T` if this is `Ok(T)`, or `defaultValue`
					T unwrapOr(T defaultValue);

					/// @brief Returns the contained `T` if this is `Ok(T)`, consuming this `Result<T, E>`.
					/// If this is not `Ok(T)`, then returns the value generated by `defaultGenerator`
					///
					/// @param defaultGenerator - The function to generate the value returned if this is `Err(E`)
					///
					/// @return  The contained `T` if this is `Ok(T)`, or the value generated by `defaultGenerator`
					T unwrapOrElse(std::function<T() const> defaultGenerator);

					/// @brief Returns the contained `E` if this is `Err(E)`, consuming this `Result<T, E>`.
					/// If this is not `Err(E)`, then `E` will be a default value (if a default
					/// constructor is available) or uninitialized (if one is not available)
					///
					/// @return The contained `E`
					E unwrapErr();

					/// @brief Converts this `Result<T, E>` to an `Option<T>`,
					/// consuming this `Result<T, E>` and discarding the error, if any
					///
					/// @return `Option<T>`
					Option<T> ok();

					/// @brief Converts this `Result<T, E>` to an `Option<E>`,
					/// consuming this `Result<T, E>` and discarding the success value, if any
					///
					/// @return `Option<E>`
					Option<E> err();

					/// @brief Maps this `Result<T, E>` to a `Result<U, E>`,
					/// returning `Ok(U)` (mapped by `mapFunc`) if this is an `Ok(T)`,
					/// or `Err(E)` if this is `Err(E)`
					///
					/// @tparam U - The type to map to
					/// @param mapFunc - The function to perform the mapping
					///
					/// @return `Ok(U)` if this is `Ok(T)`, or `Err(E)`
					template<typename U>
						Result<U, E> map(std::function<U(T) const> mapFunc) const;

					/// @brief Maps this `Result<T, E>` to a `U`,
					/// returning `U` (mapped by `mapFunc`) if this is `Ok(T)`,
					/// or `defaultValue` if this is `Err(E)`
					///
					/// @tparam U - The type to map to
					/// @param mapFunc - The function to perform the mapping
					/// @param defaultValue - The default value
					///
					/// @return The result of the mapping if this is `Ok(T)`, or `defaultValue`
					template<typename U>
						U mapOr(std::function<U(T) const> mapFunc, U defaultValue) const;

					/// @brief Maps this `Result<T, E>` to a `U`,
					/// returning `U` (mapped by `mapFunc`) if this is `Ok(T)`,
					/// or the value returned by `defaultGenerator` if this is `Err(E)`
					///
					/// @tparam U - The type to map to
					/// @param mapFunc - The function to perform the mapping
					/// @param defaultGenerator - The function to generate the default value
					///
					/// @return The result of the mapping if this is `Ok(T)`,
					///			or the value returned by `defaultGenerator`
					template<typename U>
						U mapOrElse(std::function<U(T) const> mapFunc,
								std::function<U() const> defaultGenerator) const;

					/// @brief Maps this `Result<T, E>` to a `Result<T, F>`,
					/// returning `Ok(T)` if this is `Ok(T)`,
					/// or `Err(F)` (mapped by `mapFunc`) if this is `Err(E)`
					///
					/// @tparam F - The type to map to
					///				Must be an `Error` type (`apex::utils::Error`)
					/// @param mapFunc - The function to perform the mapping
					///
					/// @return `Ok(T)` if this is `Ok(T)`, or `Err(F)` if this is `Err(E)`
					template<typename F>
						Result<T, F> mapErr(std::function<F(E) const> mapFunc) const;

				private:
					Result(T ok);
					Result(E err);
					Result();

					///the value representing success
					T mOk;
					///the value representing failure
					E mErr;
					///whether this is `Ok(T)` (`true`) or `Err(E)` (`false`)
					bool mIsOk = false;
			};

		/// @brief Represents the result of an operation that can fail.
		/// Every `Result` is either `Ok(T)`, indicating success and containing a value
		/// or `Err(E)`, indicating failure and containing an `Error` type
		///
		/// @tparam T - the type contained in the case of success
		/// @tparam E - the `Error` type contained in the case of failure
		template<typename T, typename E>
			class Result<T*, E> {
				public:
					static_assert(std::is_base_of<Error, E>::value, "E must be an Error type");
					~Result();

					/// @brief Constructs a `Result<T, E>` as the `Ok(T)` variant, containing `ok`
					///
					/// @param ok - the success value
					///
					/// @return `Ok(T)`
					static Result<T*, E> Ok(T* ok);

					/// @brief Constructs a `Result<T, E>` as the `Err(E)` variant, containing `err`
					///
					/// @param err - the failure value
					///
					/// @return `Err(E)`
					static Result<T*, E> Err(E err);

					/// @brief Returns `true` if this is `Ok(T)`, `false` if this is `Err(E)`
					///
					/// @return Whether this is `Ok(T)`
					const bool isOk() const;

					/// @brief Returns `true` if this is `Err(E)`, `false` if this is `Ok(T)`
					///
					/// @return Whether this is `Err(E)`
					const bool isErr() const;

					/// @brief Returns a pointer to the contained `T` if this is `Ok(T)`,
					/// or `nullptr` if this is `Err(E)`
					///
					/// @return A pointer to the contained `T`
					const T* getMut();

					/// @brief Returns an immutable pointer to the contained `T` is this is `Ok(T)`
					/// or `nullptr` if this is `Err(E)`
					///
					/// @return An immutable pointer to the contained `T`
					const T* const getConst() const;

					/// @brief Returns the contained `T`, consuming this `Result<T, E>`.
					/// If this is not `Ok(T)`, then `T` will be a default value (if a default
					/// constructor is available) or uninitialized (if one is not available)
					///
					/// @return The contained `T`
					T* unwrap();

					/// @brief Returns the contained `T` if this is `Ok(T)`, consuming this `Result<T, E>`
					/// If this is not `Ok(T)`, then returns `defaultValue`
					///
					/// @param defaultValue - The value to return if this is `Err(E)`
					///
					/// @return The contained `T` if this is `Ok(T)`, or `defaultValue`
					T* unwrapOr(T* defaultValue);

					/// @brief Returns the contained `T` if this is `Ok(T)`, consuming this `Result<T, E>`.
					/// If this is not `Ok(T)`, then returns the value generated by `defaultGenerator`
					///
					/// @param defaultGenerator - The function to generate the value returned if this is `Err(E`)
					///
					/// @return  The contained `T` if this is `Ok(T)`, or the value generated by `defaultGenerator`
					T* unwrapOrElse(std::function<T* () const> defaultGenerator);

					/// @brief Returns the contained `E` if this is `Err(E)`, consuming this `Result<T, E>`.
					/// If this is not `Err(E)`, then `E` will be a default value (if a default
					/// constructor is available) or uninitialized (if one is not available)
					///
					/// @return The contained `E`
					E unwrapErr();

					/// @brief Converts this `Result<T, E>` to an `Option<T>`,
					/// consuming this `Result<T, E>` and discarding the error, if any
					///
					/// @return `Option<T>`
					Option<T*> ok();

					/// @brief Converts this `Result<T, E>` to an `Option<E>`,
					/// consuming this `Result<T, E>` and discarding the success value, if any
					///
					/// @return `Option<E>`
					Option<E> err();

					/// @brief Maps this `Result<T, E>` to a `Result<U, E>`,
					/// returning `Ok(U)` (mapped by `mapFunc`) if this is an `Ok(T)`,
					/// or `Err(E)` if this is `Err(E)`
					///
					/// @tparam U - The type to map to
					/// @param mapFunc - The function to perform the mapping
					///
					/// @return `Ok(U)` if this is `Ok(T)`, or `Err(E)`
					template<typename U>
						Result<U, E> map(std::function<U(T*) const> mapFunc) const;

					/// @brief Maps this `Result<T, E>` to a `U`,
					/// returning `U` (mapped by `mapFunc`) if this is `Ok(T)`,
					/// or `defaultValue` if this is `Err(E)`
					///
					/// @tparam U - The type to map to
					/// @param mapFunc - The function to perform the mapping
					/// @param defaultValue - The default value
					///
					/// @return The result of the mapping if this is `Ok(T)`, or `defaultValue`
					template<typename U>
						U mapOr(std::function<U(T*) const> mapFunc, U defaultValue) const;

					/// @brief Maps this `Result<T, E>` to a `U`,
					/// returning `U` (mapped by `mapFunc`) if this is `Ok(T)`,
					/// or the value returned by `defaultGenerator` if this is `Err(E)`
					///
					/// @tparam U - The type to map to
					/// @param mapFunc - The function to perform the mapping
					/// @param defaultGenerator - The function to generate the default value
					///
					/// @return The result of the mapping if this is `Ok(T)`,
					///			or the value returned by `defaultGenerator`
					template<typename U>
						U mapOrElse(std::function<U(T*) const> mapFunc,
								std::function<U() const> defaultGenerator) const;

					/// @brief Maps this `Result<T, E>` to a `Result<T, F>`,
					/// returning `Ok(T)` if this is `Ok(T)`,
					/// or `Err(F)` (mapped by `mapFunc`) if this is `Err(E)`
					///
					/// @tparam F - The type to map to
					///				Must be an `Error` type (`apex::utils::Error`)
					/// @param mapFunc - The function to perform the mapping
					///
					/// @return `Ok(T)` if this is `Ok(T)`, or `Err(F)` if this is `Err(E)`
					template<typename F>
						Result<T*, F> mapErr(std::function<F(E) const> mapFunc) const;

				private:
					Result(T* ok);
					Result(E err);
					Result();

					///the value representing success
					T mOk;
					///the value representing failure
					E mErr;
					///whether this is `Ok(T)` (`true`) or `Err(E)` (`false`)
					bool mIsOk = false;
			};

	}
}
