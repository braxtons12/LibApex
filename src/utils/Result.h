#pragma once

#include <functional>
#include <type_traits>

#include "Error.h"

#ifndef RESULT_DECL
#define RESULT_DECL

namespace apex {
	namespace utils {

		template<typename T>
			class Option;

		/// @brief Represents the result of an operation that can fail.
		/// Every `Result` is either `Ok(T)`, indicating success and containing a value
		/// or `Err(E)`, indicating failure and containing an `Error` type
		///
		/// @tparam T - the type contained in the case of success
		/// @tparam E - the `Error` type contained in the case of failure
		template<typename T, typename E>
			class Result {
				public:
					static_assert(std::is_base_of<Error, E>::value, "E must be an Error type");
					~Result() noexcept;

					/// @brief Constructs a `Result<T, E>` as the `Ok(T)` variant, containing `ok`
					///
					/// @param ok - the success value
					///
					/// @return `Ok(T)`
					static inline Result<T, E> Ok(T ok) noexcept {
						return Result<T, E>(ok);
					}

					/// @brief Constructs a `Result<T, E>` as the `Err(E)` variant, containing `err`
					///
					/// @param err - the failure value
					///
					/// @return `Err(E)`
					static inline Result<T, E> Err(E err) noexcept {
						return Result<T, E>(err);
					}

					/// @brief Returns `true` if this is `Ok(T)`, `false` if this is `Err(E)`
					///
					/// @return Whether this is `Ok(T)`
					bool isOk() const noexcept;

					/// @brief Returns `true` if this is `Err(E)`, `false` if this is `Ok(T)`
					///
					/// @return Whether this is `Err(E)`
					bool isErr() const noexcept;

					/// @brief Returns a pointer to the contained `T` if this is `Ok(T)`,
					/// or `nullptr` if this is `Err(E)`
					///
					/// @return A pointer to the contained `T`
					const T* getMut() noexcept;

					/// @brief Returns an immutable pointer to the contained `T` is this is `Ok(T)`
					/// or `nullptr` if this is `Err(E)`
					///
					/// @return An immutable pointer to the contained `T`
					const T* const getConst() const noexcept;

					/// @brief Returns the contained `T`, consuming this `Result<T, E>`.
					/// If this is not `Ok(T)`, then `T` will be a default value (if a default
					/// constructor is available) or uninitialized (if one is not available)
					///
					/// @return The contained `T`
					T unwrap() noexcept;

					/// @brief Returns the contained `T` if this is `Ok(T)`, consuming this `Result<T, E>`
					/// If this is not `Ok(T)`, then returns `defaultValue`
					///
					/// @param defaultValue - The value to return if this is `Err(E)`
					///
					/// @return The contained `T` if this is `Ok(T)`, or `defaultValue`
					T unwrapOr(T defaultValue) noexcept;

					/// @brief Returns the contained `T` if this is `Ok(T)`, consuming this `Result<T, E>`.
					/// If this is not `Ok(T)`, then returns the value generated by `defaultGenerator`
					///
					/// @param defaultGenerator - The function to generate the value returned if this is `Err(E`)
					///
					/// @return  The contained `T` if this is `Ok(T)`, or the value generated by `defaultGenerator`
					T unwrapOrElse(std::function<T() const> defaultGenerator) noexcept;

					/// @brief Returns the contained `E` if this is `Err(E)`, consuming this `Result<T, E>`.
					/// If this is not `Err(E)`, then `E` will be a default value (if a default
					/// constructor is available) or uninitialized (if one is not available)
					///
					/// @return The contained `E`
					E unwrapErr() noexcept;

					/// @brief Converts this `Result<T, E>` to an `Option<T>`,
					/// consuming this `Result<T, E>` and discarding the error, if any
					///
					/// @return `Option<T>`
					Option<T> ok() noexcept;

					/// @brief Converts this `Result<T, E>` to an `Option<E>`,
					/// consuming this `Result<T, E>` and discarding the success value, if any
					///
					/// @return `Option<E>`
					Option<E> err() noexcept;

					/// @brief Maps this `Result<T, E>` to a `Result<U, E>`,
					/// returning `Ok(U)` (mapped by `mapFunc`) if this is an `Ok(T)`,
					/// or `Err(E)` if this is `Err(E)`
					///
					/// @tparam U - The type to map to
					/// @param mapFunc - The function to perform the mapping
					///
					/// @return `Ok(U)` if this is `Ok(T)`, or `Err(E)`
					template<typename U>
						Result<U, E> map(std::function<U(T) const> mapFunc) const noexcept;

					/// @brief Maps this `Result<T, E>` to a `U`,
					/// returning `U` (mapped by `mapFunc`) if this is `Ok(T)`,
					/// or `defaultValue` if this is `Err(E)`
					///
					/// @tparam U - The type to map to
					/// @param mapFunc - The function to perform the mapping
					/// @param defaultValue - The default value
					///
					/// @return The result of the mapping if this is `Ok(T)`, or `defaultValue`
					template<typename U>
						U mapOr(std::function<U(T) const> mapFunc, U defaultValue) const noexcept;

					/// @brief Maps this `Result<T, E>` to a `U`,
					/// returning `U` (mapped by `mapFunc`) if this is `Ok(T)`,
					/// or the value returned by `defaultGenerator` if this is `Err(E)`
					///
					/// @tparam U - The type to map to
					/// @param mapFunc - The function to perform the mapping
					/// @param defaultGenerator - The function to generate the default value
					///
					/// @return The result of the mapping if this is `Ok(T)`,
					///			or the value returned by `defaultGenerator`
					template<typename U>
						U mapOrElse(std::function<U(T) const> mapFunc,
								std::function<U() const> defaultGenerator) const noexcept;

					/// @brief Maps this `Result<T, E>` to a `Result<T, F>`,
					/// returning `Ok(T)` if this is `Ok(T)`,
					/// or `Err(F)` (mapped by `mapFunc`) if this is `Err(E)`
					///
					/// @tparam F - The type to map to
					///				Must be an `Error` type (`apex::utils::Error`)
					/// @param mapFunc - The function to perform the mapping
					///
					/// @return `Ok(T)` if this is `Ok(T)`, or `Err(F)` if this is `Err(E)`
					template<typename F>
						Result<T, F> mapErr(std::function<F(E) const> mapFunc) const noexcept;

				private:
					Result(T ok) noexcept;
					Result(E err) noexcept;
					Result() noexcept;

					///the value representing success
					T mOk;
					///the value representing failure
					E mErr;
					///whether this is `Ok(T)` (`true`) or `Err(E)` (`false`)
					bool mIsOk = false;
			};

		/// @brief Represents the result of an operation that can fail.
		/// Every `Result` is either `Ok(T)`, indicating success and containing a value
		/// or `Err(E)`, indicating failure and containing an `Error` type
		///
		/// @tparam T - the type contained in the case of success
		/// @tparam E - the `Error` type contained in the case of failure
		template<typename T, typename E>
			class Result<T*, E> {
				public:
					static_assert(std::is_base_of<Error, E>::value, "E must be an Error type");
					~Result() noexcept;

					/// @brief Constructs a `Result<T, E>` as the `Ok(T)` variant, containing `ok`
					///
					/// @param ok - the success value
					///
					/// @return `Ok(T)`
					static inline Result<T*, E> Ok(T* ok) noexcept {
						return Result<T*, E>(ok);
					}

					/// @brief Constructs a `Result<T, E>` as the `Err(E)` variant, containing `err`
					///
					/// @param err - the failure value
					///
					/// @return `Err(E)`
					static inline Result<T*, E> Err(E err) noexcept {
						return Result<T*, E>(err);
					}

					/// @brief Returns `true` if this is `Ok(T)`, `false` if this is `Err(E)`
					///
					/// @return Whether this is `Ok(T)`
					bool isOk() const noexcept;

					/// @brief Returns `true` if this is `Err(E)`, `false` if this is `Ok(T)`
					///
					/// @return Whether this is `Err(E)`
					bool isErr() const noexcept;

					/// @brief Returns a pointer to the contained `T` if this is `Ok(T)`,
					/// or `nullptr` if this is `Err(E)`
					///
					/// @return A pointer to the contained `T`
					const T* getMut() noexcept;

					/// @brief Returns an immutable pointer to the contained `T` is this is `Ok(T)`
					/// or `nullptr` if this is `Err(E)`
					///
					/// @return An immutable pointer to the contained `T`
					const T* const getConst() const noexcept;

					/// @brief Returns the contained `T`, consuming this `Result<T, E>`.
					/// If this is not `Ok(T)`, then `T` will be a default value (if a default
					/// constructor is available) or uninitialized (if one is not available)
					///
					/// @return The contained `T`
					T* unwrap() noexcept;

					/// @brief Returns the contained `T` if this is `Ok(T)`, consuming this `Result<T, E>`
					/// If this is not `Ok(T)`, then returns `defaultValue`
					///
					/// @param defaultValue - The value to return if this is `Err(E)`
					///
					/// @return The contained `T` if this is `Ok(T)`, or `defaultValue`
					T* unwrapOr(T* defaultValue) noexcept;

					/// @brief Returns the contained `T` if this is `Ok(T)`, consuming this `Result<T, E>`.
					/// If this is not `Ok(T)`, then returns the value generated by `defaultGenerator`
					///
					/// @param defaultGenerator - The function to generate the value returned if this is `Err(E`)
					///
					/// @return  The contained `T` if this is `Ok(T)`, or the value generated by `defaultGenerator`
					T* unwrapOrElse(std::function<T* () const> defaultGenerator) noexcept;

					/// @brief Returns the contained `E` if this is `Err(E)`, consuming this `Result<T, E>`.
					/// If this is not `Err(E)`, then `E` will be a default value (if a default
					/// constructor is available) or uninitialized (if one is not available)
					///
					/// @return The contained `E`
					E unwrapErr() noexcept;

					/// @brief Converts this `Result<T, E>` to an `Option<T>`,
					/// consuming this `Result<T, E>` and discarding the error, if any
					///
					/// @return `Option<T>`
					Option<T*> ok() noexcept;

					/// @brief Converts this `Result<T, E>` to an `Option<E>`,
					/// consuming this `Result<T, E>` and discarding the success value, if any
					///
					/// @return `Option<E>`
					Option<E> err() noexcept;

					/// @brief Maps this `Result<T, E>` to a `Result<U, E>`,
					/// returning `Ok(U)` (mapped by `mapFunc`) if this is an `Ok(T)`,
					/// or `Err(E)` if this is `Err(E)`
					///
					/// @tparam U - The type to map to
					/// @param mapFunc - The function to perform the mapping
					///
					/// @return `Ok(U)` if this is `Ok(T)`, or `Err(E)`
					template<typename U>
						Result<U, E> map(std::function<U(T*) const> mapFunc) const noexcept;

					/// @brief Maps this `Result<T, E>` to a `U`,
					/// returning `U` (mapped by `mapFunc`) if this is `Ok(T)`,
					/// or `defaultValue` if this is `Err(E)`
					///
					/// @tparam U - The type to map to
					/// @param mapFunc - The function to perform the mapping
					/// @param defaultValue - The default value
					///
					/// @return The result of the mapping if this is `Ok(T)`, or `defaultValue`
					template<typename U>
						U mapOr(std::function<U(T*) const> mapFunc, U defaultValue) const noexcept;

					/// @brief Maps this `Result<T, E>` to a `U`,
					/// returning `U` (mapped by `mapFunc`) if this is `Ok(T)`,
					/// or the value returned by `defaultGenerator` if this is `Err(E)`
					///
					/// @tparam U - The type to map to
					/// @param mapFunc - The function to perform the mapping
					/// @param defaultGenerator - The function to generate the default value
					///
					/// @return The result of the mapping if this is `Ok(T)`,
					///			or the value returned by `defaultGenerator`
					template<typename U>
						U mapOrElse(std::function<U(T*) const> mapFunc,
								std::function<U() const> defaultGenerator) const noexcept;

					/// @brief Maps this `Result<T, E>` to a `Result<T, F>`,
					/// returning `Ok(T)` if this is `Ok(T)`,
					/// or `Err(F)` (mapped by `mapFunc`) if this is `Err(E)`
					///
					/// @tparam F - The type to map to
					///				Must be an `Error` type (`apex::utils::Error`)
					/// @param mapFunc - The function to perform the mapping
					///
					/// @return `Ok(T)` if this is `Ok(T)`, or `Err(F)` if this is `Err(E)`
					template<typename F>
						Result<T*, F> mapErr(std::function<F(E) const> mapFunc) const noexcept;

				private:
					Result(T* ok) noexcept;
					Result(E err) noexcept;
					Result() noexcept;

					///the value representing success
					T mOk;
					///the value representing failure
					E mErr;
					///whether this is `Ok(T)` (`true`) or `Err(E)` (`false`)
					bool mIsOk = false;
			};

	}
}

#endif //RESULT_DECL

#ifndef RESULT_IMPL
#define RESULT_IMPL

#include "Option.h"

namespace apex {
	namespace utils {

		template<typename T, typename E>
			Result<T, E>::~Result() noexcept {

			}

		/// @brief Returns `true` if this is `Ok(T)`, `false` if this is `Err(E)`
		///
		/// @return Whether this is `Ok(T)`
		template<typename T, typename E>
			bool Result<T, E>::isOk() const noexcept {
				return mIsOk;
			}

		/// @brief Returns `true` if this is `Err(E)`, `false` if this is `Ok(T)`
		///
		/// @return Whether this is `Err(E)`
		template<typename T, typename E>
			bool Result<T, E>::isErr() const noexcept {
				return !mIsOk;
			}

		/// @brief Returns a pointer to the contained `T` if this is `Ok(T)`,
		/// or `nullptr` if this is `Err(E)`
		///
		/// @return A pointer to the contained `T`
		template<typename T, typename E>
			const T* Result<T, E>::getMut() noexcept {
				if(mIsOk) return &mOk;
				else return nullptr;
			}

		/// @brief Returns an immutable pointer to the contained `T` is this is `Ok(T)`
		/// or `nullptr` if this is `Err(E)`
		///
		/// @return An immutable pointer to the contained `T`
		template<typename T, typename E>
			const T* const Result<T, E>::getConst() const noexcept {
				if(mIsOk) return &mOk;
				else return nullptr;
			}

		/// @brief Returns the contained `T`, consuming this `Result<T, E>`.
		/// If this is not `Ok(T)`, then `T` will be a default value (if a default
		/// constructor is available) or uninitialized (if one is not available)
		///
		/// @return The contained `T`
		template<typename T, typename E>
			T Result<T, E>::unwrap() noexcept {
				auto temp = *this; //work around to delete this after returning
				return std::move(mOk);
			}

		/// @brief Returns the contained `T` if this is `Ok(T)`, consuming this `Result<T, E>`
		/// If this is not `Ok(T)`, then returns `defaultValue`
		///
		/// @param defaultValue - The value to return if this is `Err(E)`
		///
		/// @return The contained `T` if this is `Ok(T)`, or `defaultValue`
		template<typename T, typename E>
			T Result<T, E>::unwrapOr(T defaultValue) noexcept {
				auto temp = *this; //work around to delete this after returning
				if(mIsOk) return std::move(mOk);
				else return defaultValue;
			}

		/// @brief Returns the contained `T` if this is `Ok(T)`, consuming this `Result<T, E>`.
		/// If this is not `Ok(T)`, then returns the value generated by `defaultGenerator`
		///
		/// @param defaultGenerator - The function to generate the value returned if this is `Err(E`)
		///
		/// @return  The contained `T` if this is `Ok(T)`, or the value generated by `defaultGenerator`
		template<typename T, typename E>
			T Result<T, E>::unwrapOrElse(std::function<T() const> defaultGenerator) noexcept {
				auto temp = *this; //work around to delete this after returning
				if(mIsOk) return std::move(mOk);
				else return defaultGenerator();
			}

		/// @brief Returns the contained `E` if this is `Err(E)`, consuming this `Result<T, E>`.
		/// If this is not `Err(E)`, then `E` will be a default value (if a default
		/// constructor is available) or uninitialized (if one is not available)
		///
		/// @return The contained `E`
		template<typename T, typename E>
			Option<T> Result<T, E>::ok() noexcept {
				auto temp = *this; //work around to delete this after returning
				if(mIsOk) return Option<T>::Some(std::move(mOk));
				else return Option<T>::None();
			}

		/// @brief Converts this `Result<T, E>` to an `Option<E>`,
		/// consuming this `Result<T, E>` and discarding the success value, if any
		///
		/// @return `Option<E>`
		template<typename T, typename E>
			Option<E> Result<T, E>::err() noexcept {
				auto temp = *this; //work around to delete this after returning
				if(!mIsOk) return Option<E>::Some(std::move(mErr));
				else return Option<T>::None();
			}

		/// @brief Maps this `Result<T, E>` to a `Result<U, E>`,
		/// returning `Ok(U)` (mapped by `mapFunc`) if this is an `Ok(T)`,
		/// or `Err(E)` if this is `Err(E)`
		///
		/// @tparam U - The type to map to
		/// @param mapFunc - The function to perform the mapping
		///
		/// @return `Ok(U)` if this is `Ok(T)`, or `Err(E)`
		template<typename T, typename E>
			template<typename U>
			Result<U, E> Result<T, E>::map(std::function<U(T) const> mapFunc) const noexcept {
				if(mIsOk) return Result<U, E>::Ok(mapFunc(mOk));
				else return Result<U, E>::Err(mErr);
			}

		/// @brief Maps this `Result<T, E>` to a `U`,
		/// returning `U` (mapped by `mapFunc`) if this is `Ok(T)`,
		/// or `defaultValue` if this is `Err(E)`
		///
		/// @tparam U - The type to map to
		/// @param mapFunc - The function to perform the mapping
		/// @param defaultValue - The default value
		///
		/// @return The result of the mapping if this is `Ok(T)`, or `defaultValue`
		template<typename T, typename E>
			template<typename U>
			U Result<T, E>::mapOr(std::function<U(T) const> mapFunc, U defaultValue) const noexcept {
				if(mIsOk) return mapFunc(mOk);
				else return defaultValue;
			}

		/// @brief Maps this `Result<T, E>` to a `U`,
		/// returning `U` (mapped by `mapFunc`) if this is `Ok(T)`,
		/// or the value returned by `defaultGenerator` if this is `Err(E)`
		///
		/// @tparam U - The type to map to
		/// @param mapFunc - The function to perform the mapping
		/// @param defaultGenerator - The function to generate the default value
		///
		/// @return The result of the mapping if this is `Ok(T)`,
		///			or the value returned by `defaultGenerator`
		template<typename T, typename E>
			template<typename U>
			U Result<T, E>::mapOrElse(std::function<U(T) const> mapFunc,
					std::function<U() const> defaultGenerator) const noexcept
			{
				if(mIsOk) return mapFunc(mOk);
				else return defaultGenerator();
			}

		/// @brief Maps this `Result<T, E>` to a `Result<T, F>`,
		/// returning `Ok(T)` if this is `Ok(T)`,
		/// or `Err(F)` (mapped by `mapFunc`) if this is `Err(E)`
		///
		/// @tparam F - The type to map to
		///				Must be an `Error` type (`apex::utils::Error`)
		/// @param mapFunc - The function to perform the mapping
		///
		/// @return `Ok(T)` if this is `Ok(T)`, or `Err(F)` if this is `Err(E)`
		template<typename T, typename E>
			template<typename F>
			Result<T, F> Result<T, E>::mapErr(std::function<F(E) const> mapFunc) const noexcept {
				static_assert(std::is_base_of<Error, F>::value, "F must be an Error type");
				if(!mIsOk) return Result<T, F>::Err(mapFunc(mErr));
				else return Result<T, F>::Ok(mOk);
			}

		template<typename T, typename E>
			Result<T, E>::Result(T ok) noexcept
			: mOk(ok), mIsOk(true)
			{

			}

		template<typename T, typename E>
			Result<T, E>::Result(E err) noexcept
			: mErr(err), mIsOk(false)
			{

			}

		template<typename T, typename E>
			Result<T, E>::Result() noexcept {

			}

		template<typename T, typename E>
			Result<T*, E>::~Result() noexcept {

			}

		/// @brief Returns `true` if this is `Ok(T)`, `false` if this is `Err(E)`
		///
		/// @return Whether this is `Ok(T)`
		template<typename T, typename E>
			bool Result<T*, E>::isOk() const noexcept {
				return mIsOk;
			}

		/// @brief Returns `true` if this is `Err(E)`, `false` if this is `Ok(T)`
		///
		/// @return Whether this is `Err(E)`
		template<typename T, typename E>
			bool Result<T*, E>::isErr() const noexcept {
				return !mIsOk;
			}

		/// @brief Returns a pointer to the contained `T` if this is `Ok(T)`,
		/// or `nullptr` if this is `Err(E)`
		///
		/// @return A pointer to the contained `T`
		template<typename T, typename E>
			const T* Result<T*, E>::getMut() noexcept {
				if(mIsOk) return mOk;
				else return nullptr;
			}

		/// @brief Returns an immutable pointer to the contained `T` is this is `Ok(T)`
		/// or `nullptr` if this is `Err(E)`
		///
		/// @return An immutable pointer to the contained `T`
		template<typename T, typename E>
			const T* const Result<T*, E>::getConst() const noexcept {
				if(mIsOk) return mOk;
				else return nullptr;
			}

		/// @brief Returns the contained `T`, consuming this `Result<T, E>`.
		/// If this is not `Ok(T)`, then `T` will be a default value (if a default
		/// constructor is available) or uninitialized (if one is not available)
		///
		/// @return The contained `T`
		template<typename T, typename E>
			T* Result<T*, E>::unwrap() noexcept {
				auto temp = *this; //work around to delete this after returning
				return std::move(mOk);
			}

		/// @brief Returns the contained `T` if this is `Ok(T)`, consuming this `Result<T, E>`
		/// If this is not `Ok(T)`, then returns `defaultValue`
		///
		/// @param defaultValue - The value to return if this is `Err(E)`
		///
		/// @return The contained `T` if this is `Ok(T)`, or `defaultValue`
		template<typename T, typename E>
			T* Result<T*, E>::unwrapOr(T* defaultValue) noexcept {
				auto temp = *this; //work around to delete this after returning
				if(mIsOk) return std::move(mOk);
				else return defaultValue;
			}

		/// @brief Returns the contained `T` if this is `Ok(T)`, consuming this `Result<T, E>`.
		/// If this is not `Ok(T)`, then returns the value generated by `defaultGenerator`
		///
		/// @param defaultGenerator - The function to generate the value returned if this is `Err(E`)
		///
		/// @return  The contained `T` if this is `Ok(T)`, or the value generated by `defaultGenerator`
		template<typename T, typename E>
			T* Result<T*, E>::unwrapOrElse(std::function<T* () const> defaultGenerator) noexcept {
				auto temp = *this; //work around to delete this after returning
				if(mIsOk) return std::move(mOk);
				else return defaultGenerator();
			}

		/// @brief Returns the contained `E` if this is `Err(E)`, consuming this `Result<T, E>`.
		/// If this is not `Err(E)`, then `E` will be a default value (if a default
		/// constructor is available) or uninitialized (if one is not available)
		///
		/// @return The contained `E`
		template<typename T, typename E>
			Option<T*> Result<T*, E>::ok() noexcept {
				auto temp = *this; //work around to delete this after returning
				if(mIsOk) return Option<T*>::Some(std::move(mOk));
				else return Option<T*>::None();
			}

		/// @brief Converts this `Result<T, E>` to an `Option<E>`,
		/// consuming this `Result<T, E>` and discarding the success value, if any
		///
		/// @return `Option<E>`
		template<typename T, typename E>
			Option<E> Result<T*, E>::err() noexcept {
				auto temp = *this; //work around to delete this after returning
				if(!mIsOk) return Option<E>::Some(std::move(mErr));
				else return Option<T*>::None();
			}

		/// @brief Maps this `Result<T, E>` to a `Result<U, E>`,
		/// returning `Ok(U)` (mapped by `mapFunc`) if this is an `Ok(T)`,
		/// or `Err(E)` if this is `Err(E)`
		///
		/// @tparam U - The type to map to
		/// @param mapFunc - The function to perform the mapping
		///
		/// @return `Ok(U)` if this is `Ok(T)`, or `Err(E)`
		template<typename T, typename E>
			template<typename U>
			Result<U, E> Result<T*, E>::map(std::function<U(T*) const> mapFunc) const noexcept {
				if(mIsOk) return Result<U, E>::Ok(mapFunc(mOk));
				else return Result<U, E>::Err(mErr);
			}

		/// @brief Maps this `Result<T, E>` to a `U`,
		/// returning `U` (mapped by `mapFunc`) if this is `Ok(T)`,
		/// or `defaultValue` if this is `Err(E)`
		///
		/// @tparam U - The type to map to
		/// @param mapFunc - The function to perform the mapping
		/// @param defaultValue - The default value
		///
		/// @return The result of the mapping if this is `Ok(T)`, or `defaultValue`
		template<typename T, typename E>
			template<typename U>
			U Result<T*, E>::mapOr(std::function<U(T*) const> mapFunc, U defaultValue) const noexcept {
				if(mIsOk) return mapFunc(mOk);
				else return defaultValue;
			}

		/// @brief Maps this `Result<T, E>` to a `U`,
		/// returning `U` (mapped by `mapFunc`) if this is `Ok(T)`,
		/// or the value returned by `defaultGenerator` if this is `Err(E)`
		///
		/// @tparam U - The type to map to
		/// @param mapFunc - The function to perform the mapping
		/// @param defaultGenerator - The function to generate the default value
		///
		/// @return The result of the mapping if this is `Ok(T)`,
		///			or the value returned by `defaultGenerator`
		template<typename T, typename E>
			template<typename U>
			U Result<T*, E>::mapOrElse(std::function<U(T*) const> mapFunc,
					std::function<U() const> defaultGenerator) const noexcept
			{
				if(mIsOk) return mapFunc(mOk);
				else return defaultGenerator();
			}

		/// @brief Maps this `Result<T, E>` to a `Result<T, F>`,
		/// returning `Ok(T)` if this is `Ok(T)`,
		/// or `Err(F)` (mapped by `mapFunc`) if this is `Err(E)`
		///
		/// @tparam F - The type to map to
		///				Must be an `Error` type (`apex::utils::Error`)
		/// @param mapFunc - The function to perform the mapping
		///
		/// @return `Ok(T)` if this is `Ok(T)`, or `Err(F)` if this is `Err(E)`
		template<typename T, typename E>
			template<typename F>
			Result<T*, F> Result<T*, E>::mapErr(std::function<F(E) const> mapFunc) const noexcept {
				static_assert(std::is_base_of<Error, F>::value, "F must be an Error type");
				if(!mIsOk) return Result<T*, F>::Err(mapFunc(mErr));
				else return Result<T*, F>::Ok(mOk);
			}

		template<typename T, typename E>
			Result<T*, E>::Result(T* ok) noexcept
			: mOk(ok), mIsOk(true)
			{

			}

		template<typename T, typename E>
			Result<T*, E>::Result(E err) noexcept
			: mErr(err), mIsOk(false)
			{

			}

		template<typename T, typename E>
			Result<T*, E>::Result() noexcept {

			}

	}
}

#endif //RESULT_IMPL
