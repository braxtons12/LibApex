#include "Result.h"

#include "Option.h"

namespace apex {
	namespace utils {

		template<typename T, typename E>
			Result<T, E>::~Result() {

			}

		/// @brief Constructs a `Result<T, E>` as the `Ok(T)` variant, containing `ok`
		///
		/// @param ok - the success value
		///
		/// @return `Ok(T)`
		template<typename T, typename E>
			Result<T, E> Result<T, E>::Ok(T ok) {
				return Result<T,E>(ok);
			}

		/// @brief Constructs a `Result<T, E>` as the `Err(E)` variant, containing `err`
		///
		/// @param err - the failure value
		///
		/// @return `Err(E)`
		template<typename T, typename E>
			Result<T, E> Result<T, E>::Err(E err) {
				return Result<T, E>(err);
			}

		/// @brief Returns `true` if this is `Ok(T)`, `false` if this is `Err(E)`
		///
		/// @return Whether this is `Ok(T)`
		template<typename T, typename E>
			const bool Result<T, E>::isOk() const {
				return mIsOk;
			}

		/// @brief Returns `true` if this is `Err(E)`, `false` if this is `Ok(T)`
		///
		/// @return Whether this is `Err(E)`
		template<typename T, typename E>
			const bool Result<T, E>::isErr() const {
				return !mIsOk;
			}

		/// @brief Returns a pointer to the contained `T` if this is `Ok(T)`,
		/// or `nullptr` if this is `Err(E)`
		///
		/// @return A pointer to the contained `T`
		template<typename T, typename E>
			const T* Result<T, E>::getMut() {
				if(mIsOk) return &mOk;
				else return nullptr;
			}

		/// @brief Returns an immutable pointer to the contained `T` is this is `Ok(T)`
		/// or `nullptr` if this is `Err(E)`
		///
		/// @return An immutable pointer to the contained `T`
		template<typename T, typename E>
			const T* const Result<T, E>::getConst() const {
				if(mIsOk) return &mOk;
				else return nullptr;
			}

		/// @brief Returns the contained `T`, consuming this `Result<T, E>`.
		/// If this is not `Ok(T)`, then `T` will be a default value (if a default
		/// constructor is available) or uninitialized (if one is not available)
		///
		/// @return The contained `T`
		template<typename T, typename E>
			T Result<T, E>::unwrap() {
				auto temp = *this; //work around to delete this after returning
				return std::move(mOk);
			}

		/// @brief Returns the contained `T` if this is `Ok(T)`, consuming this `Result<T, E>`
		/// If this is not `Ok(T)`, then returns `defaultValue`
		///
		/// @param defaultValue - The value to return if this is `Err(E)`
		///
		/// @return The contained `T` if this is `Ok(T)`, or `defaultValue`
		template<typename T, typename E>
			T Result<T, E>::unwrapOr(T defaultValue) {
				auto temp = *this; //work around to delete this after returning
				if(mIsOk) return std::move(mOk);
				else return defaultValue;
			}

		/// @brief Returns the contained `T` if this is `Ok(T)`, consuming this `Result<T, E>`.
		/// If this is not `Ok(T)`, then returns the value generated by `defaultGenerator`
		///
		/// @param defaultGenerator - The function to generate the value returned if this is `Err(E`)
		///
		/// @return  The contained `T` if this is `Ok(T)`, or the value generated by `defaultGenerator`
		template<typename T, typename E>
			T Result<T, E>::unwrapOrElse(std::function<T() const> defaultGenerator) {
				auto temp = *this; //work around to delete this after returning
				if(mIsOk) return std::move(mOk);
				else return defaultGenerator();
			}

		/// @brief Returns the contained `E` if this is `Err(E)`, consuming this `Result<T, E>`.
		/// If this is not `Err(E)`, then `E` will be a default value (if a default
		/// constructor is available) or uninitialized (if one is not available)
		///
		/// @return The contained `E`
		template<typename T, typename E>
			Option<T> Result<T, E>::ok() {
				auto temp = *this; //work around to delete this after returning
				if(mIsOk) return Option<T>::Some(std::move(mOk));
				else return Option<T>::None();
			}

		/// @brief Converts this `Result<T, E>` to an `Option<E>`,
		/// consuming this `Result<T, E>` and discarding the success value, if any
		///
		/// @return `Option<E>`
		template<typename T, typename E>
			Option<E> Result<T, E>::err() {
				auto temp = *this; //work around to delete this after returning
				if(!mIsOk) return Option<E>::Some(std::move(mErr));
				else return Option<T>::None();
			}

		/// @brief Maps this `Result<T, E>` to a `Result<U, E>`,
		/// returning `Ok(U)` (mapped by `mapFunc`) if this is an `Ok(T)`,
		/// or `Err(E)` if this is `Err(E)`
		///
		/// @tparam U - The type to map to
		/// @param mapFunc - The function to perform the mapping
		///
		/// @return `Ok(U)` if this is `Ok(T)`, or `Err(E)`
		template<typename T, typename E>
			template<typename U>
			Result<U, E> Result<T, E>::map(std::function<U(T) const> mapFunc) const {
				if(mIsOk) return Result<U, E>::Ok(mapFunc(mOk));
				else return Result<U, E>::Err(mErr);
			}

		/// @brief Maps this `Result<T, E>` to a `U`,
		/// returning `U` (mapped by `mapFunc`) if this is `Ok(T)`,
		/// or `defaultValue` if this is `Err(E)`
		///
		/// @tparam U - The type to map to
		/// @param mapFunc - The function to perform the mapping
		/// @param defaultValue - The default value
		///
		/// @return The result of the mapping if this is `Ok(T)`, or `defaultValue`
		template<typename T, typename E>
			template<typename U>
			U Result<T, E>::mapOr(std::function<U(T) const> mapFunc, U defaultValue) const {
				if(mIsOk) return mapFunc(mOk);
				else return defaultValue;
			}

		/// @brief Maps this `Result<T, E>` to a `U`,
		/// returning `U` (mapped by `mapFunc`) if this is `Ok(T)`,
		/// or the value returned by `defaultGenerator` if this is `Err(E)`
		///
		/// @tparam U - The type to map to
		/// @param mapFunc - The function to perform the mapping
		/// @param defaultGenerator - The function to generate the default value
		///
		/// @return The result of the mapping if this is `Ok(T)`,
		///			or the value returned by `defaultGenerator`
		template<typename T, typename E>
			template<typename U>
			U Result<T, E>::mapOrElse(std::function<U(T) const> mapFunc,
					std::function<U() const> defaultGenerator) const
			{
				if(mIsOk) return mapFunc(mOk);
				else return defaultGenerator();
			}

		/// @brief Maps this `Result<T, E>` to a `Result<T, F>`,
		/// returning `Ok(T)` if this is `Ok(T)`,
		/// or `Err(F)` (mapped by `mapFunc`) if this is `Err(E)`
		///
		/// @tparam F - The type to map to
		///				Must be an `Error` type (`apex::utils::Error`)
		/// @param mapFunc - The function to perform the mapping
		///
		/// @return `Ok(T)` if this is `Ok(T)`, or `Err(F)` if this is `Err(E)`
		template<typename T, typename E>
			template<typename F>
			Result<T, F> Result<T, E>::mapErr(std::function<F(E) const> mapFunc) const {
				static_assert(std::is_base_of<Error, F>::value, "F must be an Error type");
				if(!mIsOk) return Result<T, F>::Err(mapFunc(mErr));
				else return Result<T, F>::Ok(mOk);
			}

		template<typename T, typename E>
			Result<T, E>::Result(T ok)
			: mOk(ok), mIsOk(true)
			{

			}

		template<typename T, typename E>
			Result<T, E>::Result(E err)
			: mErr(err), mIsOk(false)
			{

			}

		template<typename T, typename E>
			Result<T, E>::Result() {

			}

		template<typename T, typename E>
			Result<T*, E>::~Result() {

			}

		/// @brief Constructs a `Result<T, E>` as the `Ok(T)` variant, containing `ok`
		///
		/// @param ok - the success value
		///
		/// @return `Ok(T)`
		template<typename T, typename E>
			Result<T*, E> Result<T*, E>::Ok(T* ok) {
				return Result<T*, E>(ok);
			}

		/// @brief Constructs a `Result<T, E>` as the `Err(E)` variant, containing `err`
		///
		/// @param err - the failure value
		///
		/// @return `Err(E)`
		template<typename T, typename E>
			Result<T*, E> Result<T*, E>::Err(E err) {
				return Result<T*, E>(err);
			}

		/// @brief Returns `true` if this is `Ok(T)`, `false` if this is `Err(E)`
		///
		/// @return Whether this is `Ok(T)`
		template<typename T, typename E>
			const bool Result<T*, E>::isOk() const {
				return mIsOk;
			}

		/// @brief Returns `true` if this is `Err(E)`, `false` if this is `Ok(T)`
		///
		/// @return Whether this is `Err(E)`
		template<typename T, typename E>
			const bool Result<T*, E>::isErr() const {
				return !mIsOk;
			}

		/// @brief Returns a pointer to the contained `T` if this is `Ok(T)`,
		/// or `nullptr` if this is `Err(E)`
		///
		/// @return A pointer to the contained `T`
		template<typename T, typename E>
			const T* Result<T*, E>::getMut() {
				if(mIsOk) return mOk;
				else return nullptr;
			}

		/// @brief Returns an immutable pointer to the contained `T` is this is `Ok(T)`
		/// or `nullptr` if this is `Err(E)`
		///
		/// @return An immutable pointer to the contained `T`
		template<typename T, typename E>
			const T* const Result<T*, E>::getConst() const {
				if(mIsOk) return mOk;
				else return nullptr;
			}

		/// @brief Returns the contained `T`, consuming this `Result<T, E>`.
		/// If this is not `Ok(T)`, then `T` will be a default value (if a default
		/// constructor is available) or uninitialized (if one is not available)
		///
		/// @return The contained `T`
		template<typename T, typename E>
			T* Result<T*, E>::unwrap() {
				auto temp = *this; //work around to delete this after returning
				return std::move(mOk);
			}

		/// @brief Returns the contained `T` if this is `Ok(T)`, consuming this `Result<T, E>`
		/// If this is not `Ok(T)`, then returns `defaultValue`
		///
		/// @param defaultValue - The value to return if this is `Err(E)`
		///
		/// @return The contained `T` if this is `Ok(T)`, or `defaultValue`
		template<typename T, typename E>
			T* Result<T*, E>::unwrapOr(T* defaultValue) {
				auto temp = *this; //work around to delete this after returning
				if(mIsOk) return std::move(mOk);
				else return defaultValue;
			}

		/// @brief Returns the contained `T` if this is `Ok(T)`, consuming this `Result<T, E>`.
		/// If this is not `Ok(T)`, then returns the value generated by `defaultGenerator`
		///
		/// @param defaultGenerator - The function to generate the value returned if this is `Err(E`)
		///
		/// @return  The contained `T` if this is `Ok(T)`, or the value generated by `defaultGenerator`
		template<typename T, typename E>
			T* Result<T*, E>::unwrapOrElse(std::function<T* () const> defaultGenerator) {
				auto temp = *this; //work around to delete this after returning
				if(mIsOk) return std::move(mOk);
				else return defaultGenerator();
			}

		/// @brief Returns the contained `E` if this is `Err(E)`, consuming this `Result<T, E>`.
		/// If this is not `Err(E)`, then `E` will be a default value (if a default
		/// constructor is available) or uninitialized (if one is not available)
		///
		/// @return The contained `E`
		template<typename T, typename E>
			Option<T*> Result<T*, E>::ok() {
				auto temp = *this; //work around to delete this after returning
				if(mIsOk) return Option<T*>::Some(std::move(mOk));
				else return Option<T*>::None();
			}

		/// @brief Converts this `Result<T, E>` to an `Option<E>`,
		/// consuming this `Result<T, E>` and discarding the success value, if any
		///
		/// @return `Option<E>`
		template<typename T, typename E>
			Option<E> Result<T*, E>::err() {
				auto temp = *this; //work around to delete this after returning
				if(!mIsOk) return Option<E>::Some(std::move(mErr));
				else return Option<T*>::None();
			}

		/// @brief Maps this `Result<T, E>` to a `Result<U, E>`,
		/// returning `Ok(U)` (mapped by `mapFunc`) if this is an `Ok(T)`,
		/// or `Err(E)` if this is `Err(E)`
		///
		/// @tparam U - The type to map to
		/// @param mapFunc - The function to perform the mapping
		///
		/// @return `Ok(U)` if this is `Ok(T)`, or `Err(E)`
		template<typename T, typename E>
			template<typename U>
			Result<U, E> Result<T*, E>::map(std::function<U(T*) const> mapFunc) const {
				if(mIsOk) return Result<U, E>::Ok(mapFunc(mOk));
				else return Result<U, E>::Err(mErr);
			}

		/// @brief Maps this `Result<T, E>` to a `U`,
		/// returning `U` (mapped by `mapFunc`) if this is `Ok(T)`,
		/// or `defaultValue` if this is `Err(E)`
		///
		/// @tparam U - The type to map to
		/// @param mapFunc - The function to perform the mapping
		/// @param defaultValue - The default value
		///
		/// @return The result of the mapping if this is `Ok(T)`, or `defaultValue`
		template<typename T, typename E>
			template<typename U>
			U Result<T*, E>::mapOr(std::function<U(T*) const> mapFunc, U defaultValue) const {
				if(mIsOk) return mapFunc(mOk);
				else return defaultValue;
			}

		/// @brief Maps this `Result<T, E>` to a `U`,
		/// returning `U` (mapped by `mapFunc`) if this is `Ok(T)`,
		/// or the value returned by `defaultGenerator` if this is `Err(E)`
		///
		/// @tparam U - The type to map to
		/// @param mapFunc - The function to perform the mapping
		/// @param defaultGenerator - The function to generate the default value
		///
		/// @return The result of the mapping if this is `Ok(T)`,
		///			or the value returned by `defaultGenerator`
		template<typename T, typename E>
			template<typename U>
			U Result<T*, E>::mapOrElse(std::function<U(T*) const> mapFunc,
					std::function<U() const> defaultGenerator) const
			{
				if(mIsOk) return mapFunc(mOk);
				else return defaultGenerator();
			}

		/// @brief Maps this `Result<T, E>` to a `Result<T, F>`,
		/// returning `Ok(T)` if this is `Ok(T)`,
		/// or `Err(F)` (mapped by `mapFunc`) if this is `Err(E)`
		///
		/// @tparam F - The type to map to
		///				Must be an `Error` type (`apex::utils::Error`)
		/// @param mapFunc - The function to perform the mapping
		///
		/// @return `Ok(T)` if this is `Ok(T)`, or `Err(F)` if this is `Err(E)`
		template<typename T, typename E>
			template<typename F>
			Result<T*, F> Result<T*, E>::mapErr(std::function<F(E) const> mapFunc) const {
				static_assert(std::is_base_of<Error, F>::value, "F must be an Error type");
				if(!mIsOk) return Result<T*, F>::Err(mapFunc(mErr));
				else return Result<T*, F>::Ok(mOk);
			}

		template<typename T, typename E>
			Result<T*, E>::Result(T* ok)
			: mOk(ok), mIsOk(true)
			{

			}

		template<typename T, typename E>
			Result<T*, E>::Result(E err)
			: mErr(err), mIsOk(false)
			{

			}

		template<typename T, typename E>
			Result<T*, E>::Result() {

			}

	}
}
